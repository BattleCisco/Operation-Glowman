using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.SceneManagement;
using UnityStandardAssets.Characters.ThirdPerson;

public enum AIState {Patrolling, Hunting }

/// <summary>
/// An patrolling guard looking for the player.
/// </summary>
[RequireComponent(typeof(Animator))]
[RequireComponent(typeof(CapsuleCollider))]
[RequireComponent(typeof(Rigidbody))]
[RequireComponent(typeof(ThirdPersonCharacter))]
[RequireComponent(typeof(NavMeshAgent))]
public class AIController : MonoBehaviour
{
    /// <summary>
    /// Keeps track of all the active guards.
    /// </summary>
    public static List<Transform> GuardsInPlay = new List<Transform>(); 

    /// <summary>
    /// The guard needs a reference to the player in order detect if the player is within view.
    /// </summary>
    ThirdPersonCharacter thirdPersonCharacter;
    NavMeshAgent agent;
    public Transform player;

    /// <summary>
    /// The starting Node of it's pattern, where it expands upon until it hits a dead end.
    /// </summary>
    public Node startingNode;

    /// <summary>
    /// A path generated by the seed provided by the <b>HashController</b>. 
    /// </summary>
    List<Node> pathing;
    /// <summary>
    /// If rateOfChange is positive, the AI is going forward in the array, if negative backwards.
    /// </summary>
    int rateOfChange = -1;
    /// <summary>
    /// Keeps track of the current destination.
    /// </summary>
    int currentDestination = 0;

    /// <summary>
    /// Various detection values.
    /// </summary>
    public float fieldOfViewAngle = 110f;
    public float fieldOfViewAngleDuringPatrol = 110f;
    public float fieldOfViewAngleDuringHunt = 240f;
    public float lengthOfView = 3f;
    public float huntingSpeed = 0.75f;
    public float patrolingSpeed = 0.5f;
    public float timeUntilSwitchingToPatrolSpeed = 5f;
    public float timeUntilAbandonedSearch = 15f;

    /// <summary>
    /// Vision cone related things
    /// </summary>
    public float meshResoulutionOfVisionCone;
    public LayerMask obstacleMask;
    public MeshFilter viewMeshFilter;
    Mesh viewMesh;

    /// <summary>
    /// Keep track of how long ago the player was spotted.
    /// </summary>
    float timeOfSight = 0f;
    bool playerInSight = false;
    public Vector3 playerLastSighting = Vector3.zero;

    /// <summary>
    /// The finite state machine for the AI, it goes into "Hunt" mode if it spots the player inside it's view cone. 
    /// If the player avoids the AI for long enough, it will go back into patrolling.
    /// </summary>
    AIState state = AIState.Patrolling;

    public AudioSource soundPlayer;

    public AudioClip runningSound;
    public AudioClip walkingSound;

    void Start() {
        thirdPersonCharacter = GetComponent<ThirdPersonCharacter>();
        agent = GetComponent<NavMeshAgent>();
        pathing = GeneratePath();
        agent.updateRotation = false;
        agent.SetDestination(pathing[0].transform.position);
        GuardsInPlay.Add(transform);

        viewMesh = new Mesh();
        viewMesh.name = "View Mesh";
        viewMeshFilter.mesh = viewMesh;

        soundPlayer = GetComponent<AudioSource>();
    }

    void OnDestroy() {
        GuardsInPlay.Remove(transform);
    }

    public struct ViewCastInfo {
        public bool hit;
        public Vector3 point;
        public float distance;
        public float angle;
        public ViewCastInfo(bool _hit, Vector3 _point, float _distance, float _angle) {
            hit = _hit;
            point = _point;
            distance = _distance;
            angle = _angle;
        }
    }

    ViewCastInfo ViewCast(float globalAngle) {
        Vector3 direction = DirectionFromAngle(globalAngle, true);
        RaycastHit hit;

        if (Physics.Raycast(transform.position, direction, out hit, lengthOfView, obstacleMask))
            return new ViewCastInfo(true, hit.point, hit.distance, globalAngle);
        return new ViewCastInfo(false, transform.position + direction * lengthOfView, lengthOfView, globalAngle);
    }

    public Vector3 DirectionFromAngle(float angleinDegrees, bool angleIsGlobal) {
        if (!angleIsGlobal) {
            angleinDegrees += transform.eulerAngles.y;
        }
        return new Vector3(Mathf.Sin(angleinDegrees * Mathf.Deg2Rad), 0f, Mathf.Cos(angleinDegrees * Mathf.Deg2Rad));
    }

    void DrawFieldOfView() {
        int stepCount = Mathf.RoundToInt(fieldOfViewAngle * meshResoulutionOfVisionCone);
        float stepAngleSize = fieldOfViewAngle / stepCount;

        List<Vector3> viewPoints = new List<Vector3>();
        for(int i = 0; i <= stepCount; i++) {
            float angle = transform.eulerAngles.y - fieldOfViewAngle / 2 + stepAngleSize * i;
            ViewCastInfo newViewCast = ViewCast(angle);
            viewPoints.Add(newViewCast.point);
        }

        int vertexCount = viewPoints.Count + 1;
        Vector3[] vertices = new Vector3[vertexCount];
        int[] triangles = new int[(vertexCount - 2) * 3];

        vertices[0] = Vector3.zero;
        for(int i = 0; i < vertexCount - 1; i++) {
            vertices[i + 1] = transform.InverseTransformPoint(viewPoints[i]);
            
            if (i < vertexCount - 2) {
                triangles[i * 3] = 0;
                triangles[i * 3 + 1] = i + 1;
                triangles[i * 3 + 2] = i + 2;
            }
        }

        viewMesh.Clear();
        viewMesh.vertices = vertices;
        viewMesh.triangles = triangles;
        viewMesh.RecalculateNormals();
    }

    void LateUpdate() {
        DrawFieldOfView();
    }

    void Update() {

        if(!soundPlayer.isPlaying) {
            switch (state) {
                case AIState.Patrolling:
                    soundPlayer.clip = walkingSound;
                    soundPlayer.Play();
                    break;
                case AIState.Hunting:
                    soundPlayer.clip = runningSound;
                    soundPlayer.Play();
                    break;
            }
        }

        if (Mathf.Abs(Vector3.Angle(transform.forward, player.position - transform.position)) < (fieldOfViewAngle / 2f)) {
            RaycastHit raycastHit;
            if (Physics.Raycast(transform.position, player.position - transform.position, out raycastHit, lengthOfView) && raycastHit.transform.CompareTag("Player")) {
                playerInSight = true;
            }
            else {
                playerInSight = false;
            }
        }

        if(!Flags.flags.pausedGuards) {
            switch (state) {
                case AIState.Patrolling:
                    if (agent.remainingDistance > agent.stoppingDistance)
                        thirdPersonCharacter.Move(agent.desiredVelocity, false, false);
                    else {
                        if (currentDestination == 0 || currentDestination == (pathing.Count - 1))
                            rateOfChange *= -1;
                        currentDestination += rateOfChange;
                        agent.SetDestination(pathing[currentDestination].transform.position);
                        thirdPersonCharacter.Move(agent.desiredVelocity, false, false);
                    }

                    if (playerInSight) {
                        state = AIState.Hunting;

                        fieldOfViewAngle = fieldOfViewAngleDuringHunt;
                        timeOfSight = Time.timeSinceLevelLoad;
                        playerLastSighting = player.transform.position;
                        agent.SetDestination(player.transform.position);
                        thirdPersonCharacter.Move(agent.desiredVelocity, false, false);
                    }

                    break;
                case AIState.Hunting:
                    if (playerInSight) {
                        state = AIState.Hunting;

                        timeOfSight = Time.timeSinceLevelLoad;
                        playerLastSighting = player.transform.position;
                        agent.SetDestination(playerLastSighting);
                        thirdPersonCharacter.Move(agent.desiredVelocity, false, false);
                        agent.speed = huntingSpeed;

                        if ((player.transform.position - transform.position).sqrMagnitude < 3)
                            SceneManager.LoadScene("_Scenes/YouLose");
                    }
                    else {
                        thirdPersonCharacter.Move(agent.desiredVelocity, false, false);
                        if (Time.timeSinceLevelLoad - timeOfSight > timeUntilSwitchingToPatrolSpeed) {
                            agent.speed = patrolingSpeed;
                            fieldOfViewAngle = fieldOfViewAngleDuringHunt;
                        }
                        if (Time.timeSinceLevelLoad - timeOfSight > timeUntilAbandonedSearch) {
                            fieldOfViewAngle = fieldOfViewAngleDuringPatrol;
                            agent.speed = patrolingSpeed;
                            state = AIState.Patrolling;
                            agent.SetDestination(pathing[currentDestination].transform.position);
                            thirdPersonCharacter.Move(agent.desiredVelocity, false, false);
                        }
                    }
                    break;
            }
        }
        else {
            thirdPersonCharacter.Move(Vector3.zero, false, false);
        }
        
    }

    /// <summary>
    /// GeneratePath() raises errors during edit mode cause the HashController has not been initialized.
    /// </summary>
    void MyOnDrawGizmos() {
        List<Node> path = GeneratePath();
        for (int i = 0; i < path.Count - 1; i++) {
            Gizmos.DrawLine(
                path[i].transform.position,
                path[i + 1].transform.position);
        }
        Gizmos.DrawLine(transform.position, path[0].transform.position);

        Vector3 rightLimit = (Quaternion.Euler(0, -fieldOfViewAngle / 2f, 0) * transform.forward).normalized * lengthOfView;
        Vector3 leftLimit = (Quaternion.Euler(0, fieldOfViewAngle / 2f, 0) * transform.forward).normalized * lengthOfView;
        Gizmos.DrawLine(transform.position, transform.position + rightLimit);
        Gizmos.DrawLine(transform.position, transform.position + leftLimit);
    }
    
    /// <summary>
    /// Generates a path for the AI, starting with the first node provided.
    /// </summary>
    /// <returns>A list of coordinates to patrol around the area.</returns>
    public List<Node> GeneratePath() {
        Stack<Node> path = new Stack<Node>();
        path.Push(startingNode);

        int i = 0;
        while (true) {
            int randomInteger = HashController.instance.GetUniqueHashNumber(name, i);
            Node next = path.Peek().GetNode(randomInteger, new List<Node>(path.ToArray()));

            if (next == null) {
                break;
            }

            path.Push(next);
            i++;
        }

        return new List<Node>(path.ToArray());
    }
}
